name: Build and Deploy FastFood to AKS

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Permite execu√ß√£o manual

env:
  REGISTRY: acrfastfoodpostech.azurecr.io
  APP_IMAGE_NAME: fastfood/app
  MIGRATOR_IMAGE_NAME: fastfood/migrator
  CHART_PATH: ./helm/fastfood-chart
  RELEASE_NAME: fastfood-release
  AKS_RESOURCE_GROUP: rg-fastfood-postech
  AKS_CLUSTER_NAME: aks-fastfood-postech
  NAMESPACE: fastfood

jobs:
  build-deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      # 1. Checkout do c√≥digo
      - name: Checkout code
        uses: actions/checkout@v4

      # 2. Setup .NET
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      # 3. Restore & Build & Test
      - name: Restore dependencies
        run: dotnet restore src/Soat.Eleven.FastFood.sln

      - name: Build project
        run: dotnet build src/Soat.Eleven.FastFood.sln --configuration Release --no-restore

      - name: Run tests
        run: dotnet test src/Soat.Eleven.FastFood.sln --no-build --verbosity normal

      # 4. Login no Azure usando OIDC
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      # 5. Login no ACR
      - name: Azure Container Registry Login
        run: |
          az acr login --name acrfastfoodpostech

      # 6. Build e push das imagens (App + Migrator)
      - name: Build and push Docker images
        run: |
          # Build da imagem da aplica√ß√£o com tag latest
          docker build --target final -t $REGISTRY/$APP_IMAGE_NAME:latest .
          docker push $REGISTRY/$APP_IMAGE_NAME:latest
          
          # Build da imagem do migrator com tag latest
          docker build --target migrator -t $REGISTRY/$MIGRATOR_IMAGE_NAME:latest .
          docker push $REGISTRY/$MIGRATOR_IMAGE_NAME:latest

      # 7. Conectar no AKS
      - name: Get AKS credentials
        run: |
          # Limpar configura√ß√µes kubectl anteriores
          rm -rf ~/.kube/config || true
          
          # Obter credenciais frescas do cluster
          az aks get-credentials \
            --resource-group $AKS_RESOURCE_GROUP \
            --name $AKS_CLUSTER_NAME \
            --overwrite-existing \
            --admin
          
          # Verificar conectividade
          echo "Testing cluster connectivity..."
          kubectl cluster-info
          kubectl get nodes

      # 8. Criar namespace se n√£o existir
      - name: Create namespace
        run: |
          kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

      # 9. Setup Helm
      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: v3.15.1

      # 10. Executar Migration Job primeiro
      - name: Run Database Migration
        run: |
          # Remover job anterior se existir
          kubectl delete job migrator -n $NAMESPACE --ignore-not-found=true
          
          # Aguardar um pouco para garantir que o job foi removido
          sleep 5
          
          # Executar migration usando helm template + kubectl
          helm template migrator-job $CHART_PATH \
            --set image.migratorRepository=$REGISTRY/$MIGRATOR_IMAGE_NAME:latest \
            --set image.repository=$REGISTRY/$APP_IMAGE_NAME:latest \
            --namespace $NAMESPACE \
            --show-only templates/migrator-job.yaml \
            --show-only templates/config-map.yaml \
            --show-only templates/secret.yaml | kubectl apply -f -
          
          # Aguardar conclus√£o do job (m√°ximo 15 minutos)
          kubectl wait --for=condition=complete job/migrator -n $NAMESPACE --timeout=900s
          
          # Verificar status do job
          kubectl get job migrator -n $NAMESPACE
          kubectl logs job/migrator -n $NAMESPACE

      # 11. Deploy da aplica√ß√£o principal
      - name: Deploy Application
        run: |
          # Limpar recursos do release anterior se existir
          helm uninstall fastfood-release-migrator -n $NAMESPACE --ignore-not-found || true
          helm uninstall fastfood-release -n $NAMESPACE --ignore-not-found || true
          
          # Limpar recursos √≥rf√£os se existirem (incluindo Jobs imut√°veis)
          kubectl delete job migrator -n $NAMESPACE --ignore-not-found || true
          kubectl delete secret db-credentials -n $NAMESPACE --ignore-not-found || true
          kubectl delete configmap fastfood-config -n $NAMESPACE --ignore-not-found || true
          kubectl delete secret acr-secret -n $NAMESPACE --ignore-not-found || true
          
          # Aguardar um pouco para garantir limpeza
          sleep 10
          
          # Criar secret para ACR usando as credenciais do Azure
          kubectl create secret docker-registry acr-secret \
            --docker-server=$REGISTRY \
            --docker-username=$(az acr credential show --name acrfastfoodpostech --query "username" -o tsv) \
            --docker-password=$(az acr credential show --name acrfastfoodpostech --query "passwords[0].value" -o tsv) \
            --namespace $NAMESPACE
          
          # Deploy da aplica√ß√£o
          helm upgrade $RELEASE_NAME $CHART_PATH \
            --install \
            --set image.repository=$REGISTRY/$APP_IMAGE_NAME:latest \
            --set image.migratorRepository=$REGISTRY/$MIGRATOR_IMAGE_NAME:latest \
            --namespace $NAMESPACE \
            --wait \
            --timeout=10m

      # 12. Verificar status do deploy
      - name: Verify Deployment
        run: |
          kubectl get pods -n $NAMESPACE
          kubectl get services -n $NAMESPACE
          kubectl get ingress -n $NAMESPACE
          
          # Aguardar LoadBalancer obter IP externo (m√°ximo 5 minutos)
          echo "Aguardando IP externo do LoadBalancer..."
          kubectl wait --for=jsonpath='{.status.loadBalancer.ingress}' service/app-service -n $NAMESPACE --timeout=300s || true
          
          # Obter e exibir IP p√∫blico
          EXTERNAL_IP=$(kubectl get service app-service -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          if [ -n "$EXTERNAL_IP" ]; then
            echo "üéâ Aplica√ß√£o FastFood dispon√≠vel em: http://$EXTERNAL_IP"
            echo "üè• Health check: http://$EXTERNAL_IP/health"
            echo "üìö Swagger: http://$EXTERNAL_IP/swagger"
          else
            echo "‚ö†Ô∏è IP externo ainda n√£o foi atribu√≠do. Verifique em alguns minutos."
          fi
